# Введение

Все мы начинали свой путь программиста с разработки простых программ. Реализуемая ими тривиальная логика не требовала
особых усилий и зачастую весь исходный код проекта помещался всего в одном файле. Но со временем, по мере поступления
новых идей и требований программа росла. Становилось всё сложней и сложней вносить новые изменения в файл. Даже те
задачи, что требовали небольших модификаций, заставляли нас изучать кучу заграждающих деталей, препятствий в
виде лишнего шума, которые нужно было преодолеть, чтобы определить нужные места для правок. Но и здесь проблемы не
заканчивались. Несмотря на простоту реализуемой программой логики, её структура становилась сложной, запутанной. То что
казалось нам "локальным" изменением зачастую приводило к неожиданным последствиям, ломая поведения
в тех компонентах системы, которые мы и не собирались модифицировать изначально. Данный досадный факт заставлял нашу
смекалку работать и придумывать такие конструкции, которые одновременно реализовывали новое требование, но также
сохраняли корректность всех остальных поведений. К сожалению, такие идеи чаще всего еще сильнее усложняли систему,
добавляли новые условия и изменяли компоненты повторного использования напрямую, что увеличивало общую хрупкость
системы.

Для решения данных фундаментальных проблем была выработана такая практика как проектирование архитектуры.

Слово "архитектура" имеет достаточно много значений, даже если говорить исключительно в рамках домена разработки ПО. В
рамках данной статьи термин будет определяться как структура программы, т. е. совокупность всех тех решений, что
формируют наблюдаемое поведение. Иными словами это те самые "детали реализации".

Основная задача архитектуры заключается в оптимизации процесса труда разработчика. Таким образом, дизайн системы
является правильным если инженеру не требуется относительно больших усилий для реализаций той или иной задачи, время
работы легко прогнозируется, а изменения редко вызывают регресс в наблюдаемом поведении.

Основная операция при проектировании - это разделение. Не просто разбиение монолита на составляющие, но также и
определение отношений между получившимися частями. Важно не только наличие или отсутствие зависимости между
компонентами, но также её направленность.

Как в начале своего пути, так и во время своей уже профессиональной деятельности разработчики постоянно сталкиваются с
необходимостью разделения кода (или проектирования другими словами). Но каким образом это сделать? Какой код должен
принадлежать одному компоненту, а какой разным? Может ли простая сепарация помочь избежать проблем описанных ранее?

# High cohesion

--- Translate START ---

Сам принцип был впервые описан в работах Тома ДеМарко и Меилир Пейдж-Джонс. В своих работах они определяли его как
связанность (cohesion). Данный термин понимался авторами как описывающий функциональную схожесть элементов модуля.

--- Translate END ---

Отсюда и достаточно популярный принцип - high cohesion и low coupling. Остановимся на первой части. High cohesion
означает, что модули с похожей функциональностью должны располагаться максимально близко к другу другу. Но, он в такой
же равной степени говорит о том, что компоненты, функции которых отличаются, должны быть разделены.

Проблема заключатся в том, что функция модуля - это чрезвычайно размытое и субъективное
понятие. В то же самое время, определение того за что отвечает модуль, лежит в корне принципа high cohesion, и от него
же и зависит итоговая структура программы.

В основе хорошей структуры не может лежать субъективное суждение. Наоборот, архитектура должна строится на четких,
измеряемых параметрах из которых обязательно следуют все те положительные качества присущие программам с правильной
структурой кода.

Рассмотрим простой пример.

--- Описать пример неочевидности метрики функциональной схожести и разные следствие по разделению в итоге

Убедившись в том, что простое следование правилам основанным на функции (или предназначению) модуля не ведет нас ни к
чему определенному, логично задать вопрос - чем стоит руководствоваться в таком случае?

Рассмотрим тот же пример, но уже в динамике его изменений.

--- Описать тот же пример, но привести разные приходящие задачи, демонстрирующие то, как одни участки кода изменяются
одновременно, в то время как другие остаются прежними

Каждое такое изменение можно представить как очередную точку на оси ответственностей.

--- показать картинку с осью и точкой

Ответственность в данном контексте представляет собой причины, по которым тот или иной компонент может измениться.
Это может быть задача на доработку, исправление дефекта или реализация новой функции, то есть весь тот спектр операций в
рамках которых разработчик обычно взаимодействует с исходным кодом.

--- показать картинку с разными осями, для того чтобы подчеркнуть разные ответственности

В случае когда один элемент системы, например функция, объединяет в себе несколько ответственностей, у разработчика
появляется больше причин для его модификации. Но каким образом данный факт может негативно повлиять на итоговую
структуру программы?

# Жесткость

--- Привести в пример общую функцию обработки ошибок (с опциональным показом нотификации и моделью результата)

Мы привыкли думать об ответственностях как о некоторых группах операций. Взять эту же функцию обработки ошибки,
действительно, все что она делает, относится к этой самой обработке исключений. И многие с этим согласятся.

--- Показать что это не так и ответственностей больше (через возможные изменения диктуемые её клиентами)

Но должны ли эти ответственности быть разделены? Во многом ответ зависит от того, каким образом она модифицируется.
Какие
силы и в каком направлении заставляют разработчика изменять данную функцию.

--- Привести пример изменений ломающих совместимость с разными клиентами

Функция реализует несколько, не связанных между собой ответственностей, диктуемых её клиентами. Это как раз и выливается
в то, что изменения от одного клиента заставляют корректировать интеграцию со всеми другими пользователями данной
функции, даже если изначальное требование для последних не предназначалось. И это совершенно не удивительно, ведь их
ответственности (то есть причины для изменений) разные.

--- Привести пример изменений сохраняющихся для разных клиентов

В случае если задачи не заставляют функцию "разрываться" между своими клиента, то в таком случае ответсвенность всего
одна. Более того, если разделить эту функцию без особых на то причин, то дизайн кода станет избыточно сложным.
Избыточным, потому что появляются конструкции без которых архитектура ничего не потеряла бы. Сложным, из-за того что
появляется больше сущностей в коде, ухудшается его прозрачность (читабельность).

Попробуем решение, которое решает проблему жесткости, но на самом деле обнажает другой, более серьёзный признак.

# Хрупкость

--- Взять тот же пример и указать на то что ответственности начинают связываться друг с другом.
Могут возникать ложные абстракции, которые в последствии начинают разрываться пытаясь реализовывать не относящиеся к
друг другу вещи.

Через эти абстракции, разные ответственности связываются еще сильнее, делая все вероятнее то, что изменение в одной
ответственности вызовет непреднамеренные дефекты в других, совершенно несвязанных областях программы. В итоге, структура
программы становится хрупкой, поведение программы часто и легко ломается в самых неожиданных элементах системы.

# Разделение ответственностей

Решить возникшую проблему можно просто разделив ответственности таким образом, чтобы они не пересекались.

--- Показать разделение с возникновением общей части

Обратим внимание на то, что теперь в случае возникновения похожей причины для изменения, поменяются именно те клиенты, к
которым задача и относилась, то есть только те, кто имеют указанную ответственность. Также стоит отметить и общую часть,
которая образовалась после разделения функции. Она, самим своим существованием демонстрирует, что есть некоторая
ответственность (причина для изменения) по которой абсолютно все её клиенты должны будут измениться. Если же практика
покажет обратное, то в таком случае и данная общая часть должна перестать существовать.

# Дублирование

Абстракции и в целом мало-конкретные компоненты являются самым частым инструментом борьбы с дублированием. Многим
кажется что если код выглядит идентичным, то он обязательно является дублирующим. В реальности же все несколько сложнее.

--- Показать пример с разными клиентами и образовавшейся общей частью. Продемонстрировать причину изменения по которой
меняется только один из клиентов

Ситуация сильно напоминает ту, что была показана ранее. И это не случайно, ведь причина лежит все там же - в
ответственностях. Тот факт, что код оказался идентичным, оказался лишь случайностью. Так получилось что в данный момент
времени требования для разных компонентов совпали. Инженер преждевременно распознал данную ситуацию как истинное
дублирование и получил ситуацию приведшею все к той же хрупкости и жесткости, что были обсуждены ранее.

--- Описать определение истинного дублирование и скорректировать пример выше. Привести разные варианты (дублирование или
общий компонент)

--- Разные реализации UI телеграм для разных платформ. Использование фреймворка построения кроссплатформы

# Многомодульные приложения

Приложения растут в сложности, сегодня, встречаются проекты над которыми одновременно могут работать десятки, а то и
сотни разработчиков. Разделение приложения на модули, является достаточно популярной методикой организации работы в
таких проектах. Принцип разделения ответственностей является чрезвычайно важным в вопросе проектирования таких систем.

Понять это нам поможет более близкое рассмотрение

## Модуль свалка

--- Привести пример модуля печати документов который требует своей прямой модификации вместо представления расширения

Очевидно что такая ситуация связана с тем, что модуль печати содержит в себе много разных не связанных между собой
ответственностей.

Это вызывает жесткость, например в следствии нарушения контрактов взаимодействия из-за изменений
вызванных очередным клиентом. По своей сути, каждый клиент становится зависимым от всех остальных таких же пользователей
модуля.

--- Показать зависимость на уровне кода и диаграмме

Хрупкость также никуда не девается, ответственности переплетены достаточно сильно, это делает даже самые простые задачи
на изменение кода не простым испытанием.

Отдельно интересно отметить проблему читабельности в таких модулях

--- Наглядно показать плохую читабельность. Указать на факт работы с данным модулем как простой копипаст чужих решений.

Сама среда разработки становится вязкой, для отладки интеграции требуется подключать данный модуль с временными
изменениями в проект, что делает разработку более вязкой. Переиспользовать полезные элементы данного компонента в других
системах также не представляется возможным, ведь он содержит в себе ответственности конкретных клиентов, что может идти
в противоречие с требованиями нового проекта.

Проблемы выше были связаны с тем что модуль печати не выражал общую ответственность всех клиентов, а наоборот,
дублировал в себе ось изменений каждого своего пользователя.

## Utils модуль

Рассмотрим другой, в чем то схожий с предыдущим пример.

--- Пример с UI библиотекой и компонентами которые используются только в конкретных проектах. Таблица в проекте с
отчетами и кнопка в лендинге.

Показать как из-за этого создаются лишние релизы (а это постоянные холостые обновления и ревалидация кода), также
вероятность хрупкости из-за наличия ложной связанности через абстракции.

--- Translate START ---

Страница 280 Agile software

Когда один пакет использует другой, между ними создается зависимость. Это верно даже в том случае когда используется
лишь малая часть целой библиотеки. Каждый раз когда такая библиотека обновляется, все её клиенты должны быть
ревалидированы и собраны снова в новый релиз. Даже, несмотря на то что в самой библиотеке изменились только те классы,
которые самим клиентом не используются вовсе.

--- Translate END ---

Более того, нужные и важные релизы могут содержать в себе другие промежуточные выпуски которые, опять же, необоснованно
изменяют процесс интеграции увеличивая время на обновление

Продемонстрировать нагрузку на рантайм в виде ненужных зависимостей (например один из проектов потребовал
мультиязычность и теперь она реализуется на уровне всех компонентов, даже там где не требуется).

--- Привести пример компонентов которые всегда используются вместе (разметка кнопки и её стили)

Другой пример - зависимость от окружения, что если данная UI библиотека будет содержать функции расчета
геометрии или описывала бы полезные абстракции для работы с исключениями? Они могли бы быть полезны в проектах где
напрямую не требуется интерфейс. Это потенциальный клиент, а значит и новая возможная ответственность определяющая
окружение. Если все будет находиться в одном модуле, то это сделает невозможным повторное использование таких функций,
то есть выразится в неподвижности.

--- Нарушение обратной совместимости с неиспользуемым компонентом, новая версия мажорная хотя для нас ничего не
поменялось

--- Пример с puppeteer и константами для devices. Нельзя переиспользовать в окружении браузера. Это связанно с
ответственностями ведь я как клиент захочу знать больше констант для devices если они появятся

Описанные проблемы также связанны с содержанием разных ответственностей в одном модуле. Привести пример
с https://github.com/adobe/react-spectrum
https://react-spectrum.adobe.com/architecture.html

## Shotgun surgery

--- Translation START

Страница 281 Agile software

В большинстве приложений поддерживаемость гораздо важней чем возможность повторного использования. Если код должен быть
изменен, то предпочтительнее будет чтобы это произошло в рамках всего одного модуля, а не распространялось по
многочисленным пакетам в приложении.

Все остальные пакеты, которые не зависят от измененного элемента таким образом не должны валидироваться повторного или
снова выпущены в релиз.

CCP (Common Closure Principle) учит нас собирать в одном месте те компоненты которые скорее всего будут изменяться по
одним и тем же причинам (объеденины ответственностями). Если две сущности настолько сильно связаны (физически или
концептуально), что они все время меняются вместе, то они принадлежат одному пакету (или того ближе). Это как раз и
снижает нагрузку на релизы, проверку и распространение ПО.

--- Translation END

https://en.wikipedia.org/wiki/Shotgun_surgery

# Виды ответственностей

--- структурные ответственности (отрисовка интерфейса, управление состоянием)
--- доменные ответственности (те что описываются в рамках задачи и представляют собой наблюдаемое поведение)

--- Пример разделения файлов и папок в проекте по структурным ответственностям даёт мне информацию о том какой стек
используется
--- Пример разделения файлов и папок в проекте по доменным ответственностям говорит о том какой домен или поведение
реализуется в каких местах

--- Описать зависимость расстояния между модулями и их ответственностями

# Библиотеки

--- Библиотеки не зависят от изменяемых ответственностей на проекте. Тем самым предоставляя возможность расширения и
доконфигурации
--- Они статичны именно там, что меняется редко. Если меняется, то это другая библиотека или прямое изменение

# Архитектуры

--- Анализ популярных архитектур с точки зрения ответственностей (гексагональная и функциональная)
--- Гексагональная – разделение портов и ядра системы как элементов в основном с разными причинами для изменений (логика
формирования экшенов и их интерпретация)
--- Функциональная – разработка атомарных компонентов и из композиции таким образом, что элементы с менее стабильными
ответственностями зависят от элементов с более стабильными ответственностями Stable dependencies principle

# Анализ ответственностей на проекте

--- постоянное наблюдение за изменениями

--- Нужно продумать heat map уже на уровне самого файла (хотя возможно аннотаций будет достаточно, если по одному
коммиту и каждый коммит на определенную задачу)

--- Маппинг изменений в файлах и областях конкретного файла на задачи. Нет ли такого что над этими задачами могут
работать одновременно несколько разных людей. Нет ли такого что инициаторами этих работ являются разные люди. Разные
люди - разные частоты и направления изменений, отсюда и разные ответственности. На проекте, особенно с несколькими
заказчиками может четко выявляться тенденция при которой одни ответственности проявляются чаще чем другие. Здесь
особенно остро встает вопрос должного проектирования во избежание проблем с жесткостью и хрупкостью всего решения

--- Привести пример файла который изменялся по просьбе сначала бизнес аналитика, а потом дизайнера (лишний шум,
связанность ответственностей)

Анализ того какие файлы в проекте меняются чаще всего достаточно полезен для выявления файлов-кандидатов
на разделение (по ответственностям) https://timdeschryver.dev/bits/git-log-heatmap. При этом, то, что файл изменяется
часто не обязательно значит что в нем совмещены несколько разных ответственностей, но в большей части случаев это именно
так.

Возврат к примеру. Ответственности обнаруживаются только с течением времени, когда появляются. Однако существуют и те
что являются частыми гостями на проекте (например представление информации и её хранение), т. е. можно на опыте
разделить.
Не стоит переусердствовать иначе вязкость

# Рефакторинг

--- Подчеркнуть рефакторинг как деятельность инициатором которой является разработчик. Это дополнительная ответсвенность
которая может быть временной (мы специально отделяем модуль в котором сомневаемся от остальной системы чтобы позднее
иметь возможность изменить его в изоляции)

# Thoughts

--- клиент как источник ответственности и ответственность как потенциальный клиент
--- то что используется вместе, имеет связанные ответственности
--- Зависимость от чужих ответственностей
--- Интересно что из ответственности можно выразить и функцию модуля (верно и обратное, но именно в таком направлении
это будет сделать гораздо проще). Раз это проще понять, это проще и объяснить кому-то другому. Такой дизайн будет
гораздо сложнее нарушить, так как сами правила работы достаточно простые и понятные
--- Ответственность не появляется сама по себе, в написанном коде, напротив, она появляется только в случае наличии
причины для изменения из которых и строится тот самый вектор изменений. Векторов может быть много, одной из сложнейших
задач является определение того, какой из ответственностей принадлежит то или иное изменение.
--- Подавляющая часть процесса проектирования состоит из поиска и разделения ответственностей, построения таких границ в
системе чтобы каждое изменение затрагивало как можно меньше модулей и лишних участоков кода, не вызывало жесткость и
хрупкость системы


