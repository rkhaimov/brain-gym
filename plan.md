# Введение

Все мы начинали свой путь программиста с разработки простых программ. Реализуемая ими тривиальная логика не требовала
особых усилий и зачастую весь исходный код проекта помещался всего в одном файле. Но со временем, по мере поступления
новых идей и требований программа росла. Становилось всё сложней и сложней вносить новые изменения в файл. Даже те
задачи, что требовали небольших модификаций, заставляли нас изучать кучу заграждающих деталей, препятствий в
виде лишнего шума, которые нужно было преодолеть, чтобы определить нужные места для правок. Но и здесь проблемы не
заканчивались. Несмотря на простоту реализуемой программой логики, её структура становилась сложной, запутанной. То что
казалось нам "локальным" изменением зачастую приводило к неожиданным последствиям, ломая поведения
в тех компонентах системы, которые мы и не собирались модифицировать изначально. Данный досадный факт заставлял нашу
смекалку работать и придумывать такие конструкции, которые одновременно реализовывали новое требование, но также
сохраняли корректность всех остальных поведений. К сожалению, такие идеи чаще всего еще сильнее усложняли систему,
добавляли новые условия и изменяли компоненты повторного использования напрямую, что увеличивало общую хрупкость
системы.

Для решения данных фундаментальных проблем была выработана такая практика как проектирование архитектуры.

Слово "архитектура" имеет достаточно много значений, даже если говорить исключительно в рамках домена разработки ПО. В
рамках данной статьи термин будет определяться как структура программы, т. е. совокупность всех тех решений, что
формируют наблюдаемое поведение. Иными словами это те самые "детали реализации".

Основная задача архитектуры заключается в оптимизации процесса труда разработчика. Таким образом, дизайн системы
является правильным если инженеру не требуется относительно больших усилий для реализаций той или иной задачи, время
работы легко прогнозируется, а изменения редко вызывают регресс в наблюдаемом поведении.

Основная операция при проектировании - это разделение. Не просто разбиение монолита на составляющие, но также и
определение отношений между получившимися частями. Важно не только наличие или отсутствие зависимости между
компонентами, но также её направленность.

Как в начале своего пути, так и во время своей уже профессиональной деятельности разработчики постоянно сталкиваются с
необходимостью разделения кода (или проектирования другими словами). Но каким образом это сделать? Какой код должен
принадлежать одному компоненту, а какой разным? Может ли простая сепарация помочь избежать проблем описанных ранее?

# High cohesion

--- Translate START ---

Сам принцип был впервые описан в работах Тома ДеМарко и Меилир Пейдж-Джонс. В своих работах они определяли его как
связанность (cohesion). Данный термин понимался авторами как описывающий функциональную схожесть элементов модуля.

--- Translate END ---

Отсюда и достаточно популярный принцип - high cohesion и low coupling. Остановимся на первой части. High cohesion
означает, что модули с похожей функциональностью должны располагаться максимально близко к другу другу. Но, он в такой
же равной степени говорит о том, что компоненты, функции которых отличаются, должны быть разделены.

Проблема заключатся в том, что функция модуля - это чрезвычайно размытое и субъективное
понятие. В то же самое время, определение того за что отвечает модуль, лежит в корне принципа high cohesion, и от него
же и зависит итоговая структура программы.

В основе хорошей структуры не может лежать субъективное суждение. Наоборот, архитектура должна строится на четких,
измеряемых параметрах из которых обязательно следуют все те положительные качества присущие программам с правильной
структурой кода.

Рассмотрим простой пример.

--- Описать пример неочевидности метрики функциональной схожести и разные следствие по разделению в итоге

Убедившись в том, что простое следование правилам основанным на функции (или предназначению) модуля не ведет нас ни к
чему определенному, логично задать вопрос - чем стоит руководствоваться в таком случае?

Рассмотрим тот же пример, но уже в динамике его изменений.

--- Описать тот же пример, но привести разные приходящие задачи, демонстрирующие то, как одни участки кода изменяются
одновременно, в то время как другие остаются прежними

# Plans

--- Нужно продумать heat map уже на уровне самого файла (хотя возможно аннотаций будет достаточно, если по одному
коммиту и каждый коммит на определенную задачу)

Анализ того какие файлы в проекте меняются чаще всего достаточно полезен для выявления файлов-кандидатов
на разделение (по ответственностям) https://timdeschryver.dev/bits/git-log-heatmap. При этом, то, что файл изменяется
часто не обязательно значит что в нем совмещены несколько разных ответственностей, но в большей части случаев это именно
так.

--- Зависимость от чужих ответственностей


