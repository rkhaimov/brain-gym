# Введение

Все мы начинали свой путь программиста с разработки простых программ. Реализуемая ими тривиальная логика не требовала
особых усилий и зачастую весь исходный код проекта помещался всего в одном файле. Но со временем, по мере поступления
новых идей и требований программа росла. Становилось всё сложней и сложней вносить новые изменения в файл. Даже те
задачи, что требовали небольших модификаций, заставляли нас изучать кучу заграждающих деталей, препятствий в
виде лишнего шума, которые нужно было преодолеть, чтобы определить нужные места для правок. Но и здесь проблемы не
заканчивались. Несмотря на простоту реализуемой программой логики, её структура становилась сложной, запутанной. То что
казалось нам "локальным" изменением зачастую приводило к неожиданным последствиям, ломая поведения
в тех компонентах системы, которые мы и не собирались модифицировать изначально. Данный досадный факт заставлял нашу
смекалку работать и придумывать такие конструкции, которые одновременно реализовывали новое требование, но также
сохраняли корректность всех остальных поведений. К сожалению, такие идеи чаще всего еще сильнее усложняли систему,
добавляли новые условия и изменяли компоненты повторного использования напрямую, что увеличивало общую хрупкость
системы.

Для решения данных фундаментальных проблем была выработана такая практика как проектирование архитектуры.

Слово "архитектура" имеет достаточно много значений, даже если говорить исключительно в рамках домена разработки ПО. В
рамках данной статьи термин будет определяться как структура программы, т. е. совокупность всех тех решений, что
формируют наблюдаемое поведение. Иными словами это те самые "детали реализации".

Основная задача архитектуры заключается в оптимизации процесса труда разработчика. Таким образом, дизайн системы
является правильным если инженеру не требуется относительно больших усилий для реализаций той или иной задачи, время
работы легко прогнозируется, а изменения редко вызывают регресс в наблюдаемом поведении.

Основная операция при проектировании - это разделение. Не просто разбиение монолита на составляющие, но также и
определение отношений между получившимися частями. Важно не только наличие или отсутствие зависимости между
компонентами, но также её направленность.

Как в начале своего пути, так и во время своей уже профессиональной деятельности разработчики постоянно сталкиваются с
необходимостью разделения кода (или проектирования другими словами). Но каким образом это сделать? Какой код должен
принадлежать одному компоненту, а какой разным? Может ли простая сепарация помочь избежать проблем описанных ранее?

# High cohesion

--- Translate START ---

Сам принцип был впервые описан в работах Тома ДеМарко и Меилир Пейдж-Джонс. В своих работах они определяли его как
связанность (cohesion). Данный термин понимался авторами как описывающий функциональную схожесть элементов модуля.

--- Translate END ---

Отсюда и достаточно популярный принцип - high cohesion и low coupling. Остановимся на первой части. High cohesion
означает, что модули с похожей функциональностью должны располагаться максимально близко к другу другу. Но, он в такой
же равной степени говорит о том, что компоненты, функции которых отличаются, должны быть разделены.

Проблема заключатся в том, что функция модуля - это чрезвычайно размытое и субъективное
понятие. В то же самое время, определение того за что отвечает модуль, лежит в корне принципа high cohesion, и от него
же и зависит итоговая структура программы.

В основе хорошей структуры не может лежать субъективное суждение. Наоборот, архитектура должна строится на четких,
измеряемых параметрах из которых обязательно следуют все те положительные качества присущие программам с правильной
структурой кода.

Рассмотрим простой пример.

--- Описать пример неочевидности метрики функциональной схожести и разные следствие по разделению в итоге

Убедившись в том, что простое следование правилам основанным на функции (или предназначению) модуля не ведет нас ни к
чему определенному, логично задать вопрос - чем стоит руководствоваться в таком случае?

Рассмотрим тот же пример, но уже в динамике его изменений.

--- Описать тот же пример, но привести разные приходящие задачи, демонстрирующие то, как одни участки кода изменяются
одновременно, в то время как другие остаются прежними

Каждое такое изменение можно представить как очередную точку на оси ответственностей.

--- показать картинку с осью и точкой

Ответственность в данном контексте представляет собой причины, по которым тот или иной компонент может измениться.
Это может быть задача на доработку, исправление дефекта или реализация новой функции, то есть весь тот спектр операций в
рамках которых разработчик обычно взаимодействует с исходным кодом.

--- показать картинку с разными осями, для того чтобы подчеркнуть разные ответственности

В случае когда один элемент системы, например функция, объединяет в себе несколько ответственностей, у разработчика
появляется больше причин для его модификации. Но каким образом данный факт может негативно повлиять на итоговую
структуру программы?

# Жесткость

--- Привести в пример общую функцию обработки ошибок (с опциональным показом нотификации и моделью результата)

Функция реализует несколько, не связанных между собой ответственностей, диктуемых её клиентами. Это как раз и выливается
в то, что изменения от одного клиента заставляют корректировать интеграцию со всеми другими пользователями данной
функции, даже если изначальное требование для последних не предназначалось. И это совершенно не удивительно, ведь их
ответственности (то есть причины для изменений) разные.

Попробуем решение, которое решает проблему жесткости, но на самом деле обнажает другой, более серьёзный признак.

# Хрупкость

--- Взять тот же пример и указать на то что ответственности начинают связываться друг с другом.
Могут возникать ложные абстракции, которые в последствии начинают разрываться пытаясь реализовывать не относящиеся к
друг другу вещи.

Через эти абстракции, разные ответственности связываются еще сильнее, делая все вероятнее то, что изменение в одной
ответственности вызовет непреднамеренные дефекты в других, совершенно несвязанных областях программы. В итоге, структура
программы становится хрупкой, поведение программы часто и легко ломается в самых неожиданных элементах системы.

# Разделение ответственностей

Решить возникшую проблему можно просто разделив ответственности таким образом, чтобы они не пересекались.

--- Показать разделение с возникновением общей части

Обратим внимание на то, что теперь в случае возникновения похожей причины для изменения, поменяются именно те клиенты, к
которым задача и относилась, то есть только те, кто имеют указанную ответственность. Также стоит отметить и общую часть,
которая образовалась после разделения функции. Она, самим своим существованием демонстрирует, что есть некоторая
ответственность (причина для изменения) по которой абсолютно все её клиенты должны будут измениться. Если же практика
покажет обратное, то в таком случае и данная общая часть должна перестать существовать.

# Дублирование

Абстракции и в целом мало-конкретные компоненты являются самым частым инструментом борьбы с дублированием. Многим
кажется что если код выглядит идентичным, то он обязательно является дублирующим. В реальности же все несколько сложнее.

--- Показать пример с разными клиентами и образовавшейся общей частью. Продемонстрировать причину изменения по которой
меняется только один из клиентов

Ситуация сильно напоминает ту, что была показана ранее. И это не случайно, ведь причина лежит все там же - в
ответственностях. Тот факт, что код оказался идентичным, оказался лишь случайностью. Так получилось что в данный момент
времени требования для разных компонентов совпали. Инженер преждевременно распознал данную ситуацию как истинное
дублирование и получил ситуацию приведшею все к той же хрупкости и жесткости, что были обсуждены ранее.

--- Описать определение истинного дублирование и скорректировать пример выше. Привести разные варианты (дублирование или
общий компонент)

# Многомодульные приложения

Приложения растут в сложности, сегодня, встречаются проекты над которыми одновременно могут работать десятки, а то и
сотни разработчиков. Разделение приложения на модули, является достаточно популярной методикой организации работы в
таких проектах. Принцип разделения ответственностей является чрезвычайно важным в вопросе проектирования таких систем.

Понять это нам поможет более близкое рассмотрение

## Модуль свалка

--- Привести пример модуля печати документов который требует своей прямой модификации вместо представления расширения

Очевидно что такая ситуация связана с тем, что модуль печати содержит в себе много разных не связанных между собой
ответственностей.

Это вызывает жесткость, например в следствии нарушения контрактов взаимодействия из-за изменений
вызванных очередным клиентом. По своей сути, каждый клиент становится зависимым от всех остальных таких же пользователей
модуля.

--- Показать зависимость на уровне кода и диаграмме

Хрупкость также никуда не девается, ответственности переплетены достаточно сильно, это делает даже самые простые задачи
на изменение кода не простым испытанием.

Отдельно интересно отметить проблему читабельности в таких модулях

--- Наглядно показать плохую читабельность. Указать на факт работы с данным модулем как простой копипаст чужих решений.

Сама среда разработки становится вязкой, для отладки интеграции требуется подключать данный модуль с временными
изменениями в проект, что делает разработку более вязкой. Переиспользовать полезные элементы данного компонента в других
системах также не представляется возможным, ведь он содержит в себе ответственности конкретных клиентов, что может идти
в противоречие с требованиями нового проекта.

Проблемы выше были связаны с тем что модуль печати не выражал общую ответственность всех клиентов, а наоборот,
дублировал в себе ось изменений каждого своего пользователя.

## Utils модуль

Рассмотрим другой, в чем то схожий с предыдущим пример.

--- Пример с UI библиотекой и компонентами которые используются только в конкретных проектах. Таблица в проекте с
отчетами и кнопка в лендинге.

Показать как из-за этого создаются лишние релизы (а это постоянные холостые обновления и ревалидация кода), также
вероятность хрупкости из-за наличия ложной связанности через абстракции.

Продемонстрировать нагрузку на рантайм в виде ненужных зависимостей (например один из проектов потребовал
мультиязычность и теперь она реализуется на уровне всех компонентов, даже там где не требуется).

Другой пример - зависимость от окружения, что если данная UI библиотека будет содержать функции расчета
геометрии? Они могли бы быть полезны в проектах где напрямую не требуется интерфейс. Это потенциальный клиент, а значит
и новая возможная ответственность определяющая окружение. Если все будет находиться в одном модуле, то это сделает
невозможным повторное использование таких функций, то есть выразится в неподвижности.

Описанные проблемы также связанны с содержанием разных ответственностей в одном модуле. Привести пример
с https://github.com/adobe/react-spectrum

## Shotgun surgery

https://en.wikipedia.org/wiki/Shotgun_surgery

# Виды ответственностей

--- структурные ответственности (отрисовка интерфейса, управление состоянием)
--- доменные ответственности (те что описываются в рамках задачи и представляют собой наблюдаемое поведение)

--- Пример разделения файлов и папок в проекте по структурным ответственностям даёт мне информацию о том какой стек
используется
--- Пример разделения файлов и папок в проекте по доменным ответственностям говорит о том какой домен или поведение
реализуется в каких местах

--- Описать зависимость расстояния между модулями и их ответственностями

# Библиотеки

--- Библиотеки не зависят от изменяемых ответственностей на проекте. Тем самым предоставляя возможность расширения и
доконфигурации
--- Они статичны именно там, что меняется редко. Если меняется, то это другая библиотека или прямое изменение

# Архитектуры

--- Анализ популярных архитектур с точки зрения ответственностей (гексагональная и функциональная)
--- Гексагональная – разделение портов и ядра системы как элементов в основном с разными причинами для изменений (логика
формирования экшенов и их интерпретация)
--- Функциональная – разработка атомарных компонентов и из композиции таким образом, что элементы с менее стабильными
ответственностями зависят от элементов с более стабильными ответственностями Stable dependencies principle

# Анализ ответственностей на проекте

--- постоянное наблюдение за изменениями

--- Нужно продумать heat map уже на уровне самого файла (хотя возможно аннотаций будет достаточно, если по одному
коммиту и каждый коммит на определенную задачу)

Анализ того какие файлы в проекте меняются чаще всего достаточно полезен для выявления файлов-кандидатов
на разделение (по ответственностям) https://timdeschryver.dev/bits/git-log-heatmap. При этом, то, что файл изменяется
часто не обязательно значит что в нем совмещены несколько разных ответственностей, но в большей части случаев это именно
так.

Возврат к примеру. Ответственности обнаруживаются только с течением времени, когда появляются. Однако существуют и те
что являются частыми гостями на проекте (например представление информации и её хранение), т. е. можно на опыте разделить.
Не стоит переусердствовать иначе вязкость

# Plans

--- клиент как источник ответственности
--- Зависимость от чужих ответственностей


